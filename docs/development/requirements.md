# 知识星球WordPress同步工具 - 需求文档

## 项目概述

本项目旨在开发一个开源的知识星球内容同步工具，支持将知识星球的内容自动同步到WordPress网站。工具提供多种同步模式、自动化任务调度和友好的Web管理界面，适合个人博主和内容创作者使用。

## 核心价值

- 自动化内容迁移，节省手动复制粘贴的时间
- 保持内容的完整性和格式
- 支持增量同步，避免重复导入
- 开源免费，社区驱动

## 用户角色

- **内容创作者**: 拥有知识星球的博主，希望将内容同步到WordPress
- **技术用户**: 熟悉配置和部署的开发者
- **普通用户**: 通过Web界面进行简单配置和使用

## 功能需求

### 1. 认证与授权管理

**用户故事**: 作为内容创作者，我希望能够安全地连接我的知识星球账号，以便获取内容数据。

#### 1.1 手动Token配置
- **需求**: 支持用户手动获取并配置知识星球访问Token
- **验收标准**:
  - WHEN 用户在配置文件中输入有效Token THEN 系统能够成功验证并连接知识星球API
  - WHEN 用户输入无效Token THEN 系统显示明确的错误提示
  - IF Token过期 THEN 系统提示用户重新获取Token

#### 1.2 自动登录获取Token
- **需求**: 提供自动登录功能获取访问Token
- **验收标准**:
  - WHEN 用户提供知识星球用户名和密码 THEN 系统能够自动登录并获取Token
  - WHEN 登录失败 THEN 系统显示具体的失败原因
  - IF 需要验证码 THEN 系统提示用户手动处理

#### 1.3 Token管理
- **需求**: 自动管理Token的有效性和刷新
- **验收标准**:
  - WHEN Token即将过期 THEN 系统自动尝试刷新Token
  - WHEN Token刷新失败 THEN 系统通知用户重新认证
  - IF 系统检测到Token无效 THEN 自动停止同步任务并通知用户

### 2. 内容获取与过滤

**用户故事**: 作为内容创作者，我希望能够灵活地选择要同步的内容类型和范围，以便精确控制同步内容。

#### 2.1 全量数据同步
- **需求**: 支持同步知识星球的所有内容
- **验收标准**:
  - WHEN 用户选择全量同步 THEN 系统获取所有可访问的帖子内容
  - WHEN 内容量很大 THEN 系统支持分页获取避免超时
  - IF 获取过程中出现错误 THEN 系统能够从断点继续获取

#### 2.2 精华内容同步
- **需求**: 支持仅同步被标记为精华的内容
- **验收标准**:
  - WHEN 用户选择精华同步 THEN 系统只获取标记为精华的帖子
  - WHEN 精华状态发生变化 THEN 系统能够检测并更新WordPress对应文章

#### 2.3 标签过滤同步
- **需求**: 支持按知识星球话题标签过滤内容
- **验收标准**:
  - WHEN 用户指定特定标签 THEN 系统只同步包含该标签的内容
  - WHEN 用户指定多个标签 THEN 系统支持AND/OR逻辑组合
  - IF 标签不存在 THEN 系统提示用户并显示可用标签列表

#### 2.4 时间范围过滤
- **需求**: 支持按时间范围筛选要同步的内容
- **验收标准**:
  - WHEN 用户设置开始和结束时间 THEN 系统只同步该时间范围内的内容
  - WHEN 用户只设置开始时间 THEN 系统同步从该时间到现在的所有内容
  - IF 时间范围无效 THEN 系统显示错误提示并要求重新输入

### 3. 内容处理与转换

**用户故事**: 作为内容创作者，我希望同步的内容能够保持原有格式并正确显示图片，以便在WordPress上呈现良好的阅读体验。

#### 3.1 内容类型识别和分类
- **需求**: 准确识别知识星球中的不同内容类型并进行差异化处理
- **内容类型定义**:
  - **片刻(Moment)**：在知识星球中，没有标题、只有一段文字和几张图片的简短分享，被称为"说说"或"talk"。脚本将这种形式的内容识别为 moment。代码层面的判断依据是：topic 数据中包含 talk 字段，但 talk 字段内部没有 article 对象。
  - **文章(Post)**：
    - 知识星球中带有标题和正文的正式"文章"
    - "问答"类型的帖子
    - "任务打卡"类型的帖子
    - 其他不符合"片刻"标准的任何内容
- **验收标准**:
  - WHEN topic数据包含talk字段且无article对象 THEN 识别为片刻类型，使用简化处理流程
  - WHEN topic数据包含article对象或属于问答类型 THEN 识别为文章类型，使用完整处理流程
  - WHEN 片刻内容处理 THEN 自动生成简短标题，归类到专门分类，保持简洁格式
  - WHEN 文章内容处理 THEN 保持完整结构和格式，支持复杂的分类映射
  - IF 内容类型无法确定 THEN 默认按文章类型处理并记录警告

#### 3.2 文本格式转换
- **需求**: 将知识星球的文本格式转换为WordPress兼容格式
- **验收标准**:
  - WHEN 内容包含@提及 THEN 转换为普通文本或WordPress用户链接
  - WHEN 内容包含话题标签 THEN 转换为WordPress标签
  - WHEN 内容包含链接 THEN 保持链接的可点击性

#### 3.3 图片处理
- **需求**: 支持多种图片存储方案，用户可根据需求选择合适的存储方式
- **验收标准**:
  - WHEN 用户选择本地存储 THEN 系统下载图片到本地目录并生成相对路径链接
  - WHEN 用户选择WordPress媒体库 THEN 系统通过WordPress API上传图片到媒体库
  - WHEN 用户选择七牛云存储 THEN 系统上传图片到七牛云并使用CDN链接
  - WHEN 图片上传失败 THEN 系统记录错误并根据配置使用备选存储方案或原始链接
  - IF 存储空间不足 THEN 系统提示用户并支持切换到其他存储方案

#### 3.4 分类结构映射
- **需求**: 提供灵活的分类映射机制，支持用户自定义映射规则
- **映射规则定义**:
  - **默认映射**: 知识星球话题标签 → WordPress标签，星球分类 → WordPress分类
  - **自定义映射**: 支持正则表达式匹配和关键词映射
  - **映射优先级**: 自定义规则 > 精确匹配 > 模糊匹配 > 默认分类
  - **冲突处理**: 多个规则匹配时使用优先级最高的规则
- **验收标准**:
  - WHEN 知识星球内容有话题标签 THEN 按照映射规则转换为WordPress分类或标签
  - WHEN 用户配置自定义映射规则 THEN 系统验证规则有效性并应用到后续同步
  - WHEN 映射规则冲突 THEN 系统按照优先级选择并记录决策日志
  - WHEN 无匹配规则 THEN 使用默认分类"知识星球"并记录未映射内容
  - IF 分类不存在 THEN 系统自动在WordPress中创建新分类

### 4. WordPress集成

**用户故事**: 作为内容创作者，我希望内容能够无缝地发布到我的WordPress网站，并保持良好的组织结构。

#### 4.1 文章发布
- **需求**: 将处理后的内容发布为WordPress文章
- **验收标准**:
  - WHEN 内容处理完成 THEN 系统自动创建WordPress文章
  - WHEN 文章标题重复 THEN 系统自动添加后缀或跳过
  - IF WordPress连接失败 THEN 系统记录错误并支持重试

#### 4.2 分类和标签管理
- **需求**: 自动管理WordPress的分类和标签结构
- **验收标准**:
  - WHEN 遇到新的分类 THEN 系统自动在WordPress中创建
  - WHEN 标签不存在 THEN 系统自动创建新标签
  - IF 分类层级复杂 THEN 系统支持多级分类创建

#### 4.3 重复内容检测
- **需求**: 避免重复导入已同步的内容
- **验收标准**:
  - WHEN 内容已存在 THEN 系统跳过该内容的导入
  - WHEN 内容有更新 THEN 系统更新WordPress中的对应文章
  - IF 检测逻辑不确定 THEN 系统提示用户手动确认

### 5. 自动化同步

**用户故事**: 作为内容创作者，我希望系统能够自动同步新发布的内容，无需手动干预。

#### 5.1 增量同步
- **需求**: 只同步上次同步后新发布的内容
- **验收标准**:
  - WHEN 执行增量同步 THEN 系统只获取最后同步时间之后的内容
  - WHEN 首次运行 THEN 系统询问用户是否进行全量同步
  - IF 同步记录丢失 THEN 系统提供恢复选项

#### 5.2 定时任务
- **需求**: 支持设置定时自动同步任务
- **验收标准**:
  - WHEN 用户设置定时任务 THEN 系统按照指定时间自动执行同步
  - WHEN 定时任务执行失败 THEN 系统记录错误并通知用户
  - IF 系统重启 THEN 定时任务能够自动恢复

#### 5.3 同步状态跟踪
- **需求**: 记录和显示同步任务的执行状态
- **验收标准**:
  - WHEN 同步任务运行 THEN 系统实时显示进度和状态
  - WHEN 同步完成 THEN 系统显示同步结果统计
  - IF 同步出现错误 THEN 系统详细记录错误信息

### 6. Web管理界面

**用户故事**: 作为普通用户，我希望通过友好的响应式Web界面来配置和管理同步任务，并能实时看到系统状态变化。

#### 6.0 实时通信机制
- **需求**: 基于Redis发布/订阅机制建立实时通信
- **验收标准**:
  - WHEN 用户打开Web界面 THEN 自动建立WebSocket连接并订阅相关Redis频道
  - WHEN 后端状态发生变化 THEN 通过Redis发布消息到对应频道
  - WHEN Redis接收到消息 THEN 立即推送更新到所有订阅的WebSocket客户端
  - WHEN 网络连接中断 THEN 系统自动重连并从Redis同步最新状态
  - WHEN 多个服务实例运行 THEN 通过Redis实现跨实例的状态同步
  - IF Redis服务不可用 THEN 系统降级到SQLite轮询模式并记录警告

#### 6.1 响应式配置管理
- **需求**: 提供响应式Web界面进行系统配置
- **验收标准**:
  - WHEN 用户访问配置页面 THEN 显示所有可配置项的表单
  - WHEN 用户保存配置 THEN 系统验证配置有效性并立即保存
  - WHEN 配置保存成功 THEN 系统立即应用新配置无需重启
  - WHEN 其他用户同时在线 THEN 配置变更立即同步到所有用户界面
  - IF 配置无效 THEN 系统实时显示具体的错误信息和修复建议

#### 6.2 实时任务监控
- **需求**: 实时监控同步任务的执行状态，无需手动刷新
- **验收标准**:
  - WHEN 同步任务开始 THEN 界面立即显示任务状态变化
  - WHEN 同步进度更新 THEN 进度条实时更新百分比和处理数量
  - WHEN 任务完成 THEN 界面立即显示执行结果和统计信息
  - WHEN 任务失败 THEN 界面立即显示错误详情和建议解决方案
  - IF 多个用户同时访问 THEN 所有用户都能看到相同的实时状态

#### 6.3 实时日志查看
- **需求**: 提供实时日志查看和搜索功能
- **验收标准**:
  - WHEN 系统产生新日志 THEN 日志界面立即显示新记录
  - WHEN 用户查看日志 THEN 系统分页显示历史日志记录
  - WHEN 用户搜索日志 THEN 系统支持按时间、级别、关键词实时过滤
  - WHEN 同步任务运行 THEN 相关日志实时滚动显示
  - IF 日志更新频率过高 THEN 系统支持暂停/恢复实时更新

### 7. 数据存储管理

**用户故事**: 作为系统管理员，我希望系统能够可靠地存储和管理同步数据，并通过缓存机制提供高性能的数据访问。

#### 7.0 Redis缓存管理
- **需求**: 使用Redis作为缓存层和消息中间件
- **验收标准**:
  - WHEN 系统启动 THEN 自动连接Redis服务并验证连接状态
  - WHEN 频繁查询数据 THEN 优先从Redis缓存获取，提升响应速度
  - WHEN 数据发生变更 THEN 同时更新SQLite和Redis缓存
  - WHEN 缓存过期 THEN 自动从SQLite重新加载数据到Redis
  - WHEN Redis服务异常 THEN 系统自动降级到直接访问SQLite
  - IF 内存使用过高 THEN Redis自动清理过期和低频访问的缓存数据

#### 7.0.1 发布/订阅机制
- **需求**: 利用Redis的发布/订阅功能实现实时消息推送
- **验收标准**:
  - WHEN 同步任务状态变化 THEN 发布消息到sync_status频道
  - WHEN 配置信息更新 THEN 发布消息到config_update频道
  - WHEN 新日志产生 THEN 发布消息到log_update频道
  - WHEN WebSocket客户端连接 THEN 自动订阅相关频道
  - IF 消息发布失败 THEN 系统记录错误并尝试重新发布

#### 7.0.2 缓存策略
- **需求**: 实现智能的数据缓存策略
- **验收标准**:
  - WHEN 系统配置发生变更 THEN 立即更新Redis缓存并发布配置更新事件
  - WHEN 查询同步记录 THEN 最近100条记录缓存到Redis，TTL设置为24小时
  - WHEN 查询内容映射 THEN 活跃映射关系缓存到Redis，TTL设置为24小时
  - WHEN 内存使用超过阈值 THEN 使用LRU策略清理缓存
  - IF 缓存命中率低于50% THEN 系统调整缓存策略并记录分析日志

#### 7.1 SQLite数据库初始化
- **需求**: 系统首次运行时自动创建数据库结构
- **验收标准**:
  - WHEN 系统首次启动 THEN 自动创建SQLite数据库文件和所有必需表
  - WHEN 数据库文件不存在 THEN 系统重新创建完整的数据库结构
  - IF 数据库创建失败 THEN 系统显示详细错误信息并退出

#### 7.2 同步记录管理
- **需求**: 记录每次同步任务的详细信息
- **验收标准**:
  - WHEN 同步任务开始 THEN 系统创建同步记录并记录开始时间
  - WHEN 同步任务完成 THEN 系统更新记录状态、结束时间和统计信息
  - WHEN 同步任务失败 THEN 系统记录失败原因和错误详情
  - IF 同步中断 THEN 系统能够从记录中恢复同步状态

#### 7.3 内容映射管理
- **需求**: 维护知识星球内容与WordPress文章的映射关系
- **验收标准**:
  - WHEN 内容成功同步到WordPress THEN 系统记录知识星球ID与WordPress文章ID的映射
  - WHEN 检查重复内容 THEN 系统通过映射表快速判断内容是否已同步
  - WHEN 内容需要更新 THEN 系统通过映射关系找到对应的WordPress文章
  - IF 映射关系损坏 THEN 系统提供重建映射的功能

#### 7.4 混合配置数据存储
- **需求**: 结合SQLite持久化和Redis缓存实现高效配置管理
- **验收标准**:
  - WHEN 用户保存配置 THEN 系统将配置数据加密存储到SQLite并同步到Redis缓存
  - WHEN 系统启动 THEN 优先从Redis加载配置，如Redis不可用则从SQLite加载
  - WHEN 配置被读取 THEN 优先使用Redis缓存，缓存未命中时从SQLite加载并缓存
  - WHEN 配置发生变更 THEN 通过Redis发布配置更新消息到所有订阅者
  - WHEN 敏感信息（密码、Token）存储 THEN 使用加密算法保护数据安全
  - IF 配置数据损坏 THEN 系统使用默认配置并提示用户重新设置

#### 7.5 任务调度数据管理
- **需求**: 结合SQLite和Redis管理定时任务的调度信息
- **验收标准**:
  - WHEN 用户创建定时任务 THEN 系统将任务配置存储到SQLite并在Redis中设置任务状态
  - WHEN 定时任务执行 THEN 系统在Redis中更新任务状态并将执行记录写入SQLite
  - WHEN 任务状态变化 THEN 通过Redis发布任务状态更新消息
  - WHEN 查看任务历史 THEN 从SQLite查询历史记录并缓存到Redis
  - WHEN 系统重启 THEN 从SQLite恢复任务配置并在Redis中重建任务状态
  - IF 任务调度失败 THEN 系统记录失败原因到SQLite并通过Redis通知用户

#### 7.6 混合日志数据管理
- **需求**: 结合SQLite和Redis实现高效的日志管理
- **验收标准**:
  - WHEN 系统产生日志 THEN 同时写入SQLite持久化存储和Redis实时缓存
  - WHEN 用户查看实时日志 THEN 优先从Redis获取最新日志记录
  - WHEN 用户查询历史日志 THEN 从SQLite分页查询并缓存结果到Redis
  - WHEN 日志数据过多 THEN 系统自动清理SQLite中超过保留期限的日志
  - WHEN Redis内存不足 THEN 自动清理旧的日志缓存，保留最新1000条
  - IF 日志写入失败 THEN 系统降级到文件日志记录

#### 7.7 数据库迁移
- **需求**: 支持数据库结构的版本升级
- **验收标准**:
  - WHEN 系统版本升级 THEN 自动检测数据库版本并执行必要的迁移脚本
  - WHEN 迁移执行前 THEN 系统自动备份现有数据库
  - WHEN 迁移失败 THEN 系统能够回滚到迁移前状态
  - IF 数据库版本不兼容 THEN 系统提示用户手动处理或重新初始化

#### 7.8 数据备份与恢复
- **需求**: 提供数据备份和恢复功能
- **验收标准**:
  - WHEN 用户请求备份 THEN 系统创建完整的数据库备份文件
  - WHEN 系统定期运行 THEN 自动创建增量备份
  - WHEN 需要恢复数据 THEN 系统支持从备份文件恢复数据库
  - IF 数据库损坏 THEN 系统能够从最近的备份自动恢复

#### 7.9 性能优化
- **需求**: 通过Redis缓存确保数据访问的高效性
- **验收标准**:
  - WHEN 数据量增长 THEN 通过Redis缓存保持查询性能稳定
  - WHEN 执行复杂查询 THEN 优先使用Redis缓存，响应时间控制在100ms内
  - WHEN 并发访问数据 THEN Redis处理并发读取，SQLite处理并发写入
  - WHEN 缓存命中率下降 THEN 系统自动调整缓存策略
  - IF 性能下降 THEN 系统提供Redis和SQLite的性能分析报告

#### 7.10 数据完整性
- **需求**: 确保数据的一致性和完整性
- **验收标准**:
  - WHEN 执行数据操作 THEN 系统验证数据完整性约束
  - WHEN 发生系统异常 THEN 数据库事务能够正确回滚
  - WHEN 检测到数据不一致 THEN 系统提供数据修复功能
  - IF 外键关系损坏 THEN 系统能够检测并修复引用完整性

### 8. 系统配置与部署

**用户故事**: 作为技术用户，我希望能够轻松地部署和配置这个工具，并且有清晰的文档指导。

#### 8.1 配置文件管理
- **需求**: 支持SQLite和Redis的统一配置管理
- **验收标准**:
  - WHEN 系统首次运行 THEN 自动生成包含Redis配置的示例配置文件
  - WHEN Redis连接配置错误 THEN 系统显示具体的连接错误信息
  - WHEN Redis服务不可用 THEN 系统自动降级到SQLite模式并记录警告
  - WHEN 配置文件格式错误 THEN 系统显示具体的错误位置
  - IF Redis配置缺失 THEN 系统使用默认Redis配置（localhost:6379）

#### 8.1.1 Redis配置管理
- **需求**: 提供完整的Redis连接和性能配置
- **验收标准**:
  - WHEN 配置Redis连接 THEN 支持主机、端口、密码、数据库选择
  - WHEN 配置Redis性能 THEN 支持连接池大小、超时时间、重试次数
  - WHEN Redis需要认证 THEN 支持密码和ACL用户认证
  - WHEN 使用Redis集群 THEN 支持集群模式配置
  - IF Redis配置测试失败 THEN 系统提供详细的诊断信息

#### 8.2 Docker Compose支持
- **需求**: 提供包含Redis的完整Docker部署方案
- **验收标准**:
  - WHEN 用户使用Docker Compose部署 THEN 自动启动应用和Redis服务
  - WHEN 容器重启 THEN SQLite数据和Redis配置能够正确恢复
  - WHEN Redis容器重启 THEN 应用自动重连并恢复缓存数据
  - WHEN 需要扩展 THEN 支持多个应用实例连接同一个Redis
  - IF Redis持久化启用 THEN 提供Redis数据卷挂载配置
  - IF 需要Redis集群 THEN 提供Redis Cluster的Docker配置示例

## 非功能性需求

### 性能要求
- 支持同步大量内容（1000+篇文章）而不出现内存溢出
- 图片上传并发处理，提高同步效率
- 数据库查询优化，确保界面响应速度

### 可靠性要求
- 网络异常时能够自动重试
- 系统崩溃后能够从断点恢复
- 关键操作有完整的错误处理和日志记录

### 安全性要求
- 敏感信息（密码、Token）加密存储
- Web界面提供基本的访问控制
- 防止SQL注入和XSS攻击

### 可维护性要求
- 模块化设计，便于功能扩展
- 完整的单元测试覆盖
- 清晰的代码注释和文档

## 数据存储架构设计

### 存储架构概述
- **SQLite**: 作为主要的持久化存储，保存所有核心业务数据
- **Redis**: 作为缓存层和消息中间件，提供高性能数据访问和实时通信

### Redis数据结构设计

#### 缓存键命名规范
- 系统配置: `config:{key}`
- 同步记录: `sync_record:{id}`
- 内容映射: `content_map:{zsxq_topic_id}`
- 任务状态: `task_status:{task_id}`
- 用户会话: `session:{session_id}`
- 日志缓存: `logs:recent` (List类型，最新1000条)

#### 发布/订阅频道
- `sync_status`: 同步任务状态变化
- `config_update`: 配置更新通知
- `log_update`: 新日志消息
- `task_update`: 定时任务状态变化
- `system_alert`: 系统警告和错误

#### Redis数据类型使用
- **String**: 配置项、任务状态、缓存数据
- **Hash**: 复杂对象缓存（同步记录、内容映射）
- **List**: 日志队列、任务队列
- **Set**: 活跃会话、标签集合
- **Sorted Set**: 按时间排序的数据（如最近同步记录）

### SQLite核心数据表结构

#### sync_records (同步记录表)
- **用途**: 记录每次同步任务的执行情况
- **字段要求**:
  - id: 主键，自增整数
  - task_type: 同步类型（full/incremental/digest/tag/time_range）
  - start_time: 开始时间
  - end_time: 结束时间
  - status: 状态（running/completed/failed/cancelled）
  - total_count: 总处理数量
  - success_count: 成功数量
  - failed_count: 失败数量
  - error_message: 错误信息
  - config_snapshot: 执行时的配置快照（JSON格式）

#### content_mapping (内容映射表)
- **用途**: 维护知识星球内容与WordPress文章的映射关系
- **字段要求**:
  - id: 主键，自增整数
  - zsxq_topic_id: 知识星球话题ID（唯一索引）
  - wp_post_id: WordPress文章ID
  - zsxq_create_time: 知识星球创建时间
  - wp_publish_time: WordPress发布时间
  - last_sync_time: 最后同步时间
  - content_hash: 内容哈希值（用于检测更新）
  - sync_status: 同步状态（synced/updated/failed）

#### system_config (系统配置表)
- **用途**: 存储系统配置信息
- **字段要求**:
  - id: 主键，自增整数
  - config_key: 配置键名（唯一索引）
  - config_value: 配置值（加密存储敏感信息）
  - config_type: 配置类型（string/int/bool/json/encrypted）
  - description: 配置描述
  - created_time: 创建时间
  - updated_time: 更新时间

#### scheduled_tasks (定时任务表)
- **用途**: 管理定时同步任务
- **字段要求**:
  - id: 主键，自增整数
  - task_name: 任务名称
  - task_type: 任务类型
  - cron_expression: Cron表达式
  - is_enabled: 是否启用
  - last_run_time: 最后执行时间
  - next_run_time: 下次执行时间
  - task_config: 任务配置（JSON格式）
  - created_time: 创建时间

#### sync_logs (同步日志表)
- **用途**: 存储详细的同步日志
- **字段要求**:
  - id: 主键，自增整数
  - sync_record_id: 关联的同步记录ID
  - log_level: 日志级别（DEBUG/INFO/WARNING/ERROR）
  - module: 模块名称
  - message: 日志消息
  - extra_data: 额外数据（JSON格式）
  - created_time: 创建时间

#### image_cache (图片缓存表)
- **用途**: 管理上传到七牛云的图片信息
- **字段要求**:
  - id: 主键，自增整数
  - original_url: 原始图片URL
  - qiniu_key: 七牛云存储键名
  - qiniu_url: 七牛云访问URL
  - file_size: 文件大小
  - upload_time: 上传时间
  - content_hash: 文件哈希值

### 数据库索引策略
- sync_records: 在start_time, status字段上创建索引
- content_mapping: 在zsxq_topic_id, wp_post_id, last_sync_time上创建索引
- system_config: 在config_key上创建唯一索引
- sync_logs: 在sync_record_id, created_time, log_level上创建索引
- image_cache: 在original_url, content_hash上创建索引

### 数据保留策略

#### SQLite数据保留
- sync_logs: 保留最近30天的日志记录
- sync_records: 保留最近100次同步记录
- image_cache: 根据存储空间限制清理未使用的图片缓存

#### Redis缓存策略
- 配置缓存: TTL 1小时，修改时立即更新
- 同步记录缓存: TTL 30分钟，最多缓存100条最新记录
- 内容映射缓存: TTL 24小时，LRU清理策略
- 日志缓存: 保留最新1000条，超出时FIFO清理
- 任务状态: 无TTL，手动清理完成的任务
- 会话数据: TTL 24小时，用户活动时自动续期

#### 内存管理
- Redis最大内存限制: 512MB（可配置）
- 内存不足时使用allkeys-lru清理策略
- 定期清理过期键和无用数据

## 技术约束

- 使用Python 3.8+开发
- Web框架使用Flask + Flask-SocketIO + Redis
- 前端使用Vue.js + Element UI + Socket.IO客户端
- 持久化存储使用SQLite数据库
- 缓存和消息队列使用Redis 6.0+
- 支持Linux、macOS、Windows部署
- 开源协议使用MIT License

### 依赖服务要求
- **Redis服务**: 版本6.0+，支持发布/订阅和持久化
- **Python依赖**: redis-py, flask-socketio, sqlite3（Python内置）
- **部署要求**: 可通过Docker Compose一键部署Redis + 应用

## 验收标准

### 基本功能验收
- 能够成功连接知识星球和WordPress
- 能够同步不同类型的内容（文本、图片、链接）
- Web界面功能完整且用户友好

### 性能验收
- 同步1000篇文章的时间不超过30分钟
- Web界面响应时间不超过3秒
- 内存使用不超过512MB

### 稳定性验收
- 连续运行7天无崩溃
- 网络异常恢复后能够正常工作
- 系统重启后定时任务正常恢复

## AI辅助开发项目计划

### 第一天：TDD项目架构和Web界面原型
**AI提示词模板（架构+原型并行）**：
```
请帮我创建知识星球WordPress同步工具的完整项目结构，要求：

后端架构部分：
1. 创建项目目录结构：auth、zsxq、processor、wordpress、sync、web
2. 设置pytest配置、测试数据库、Mock框架
3. 创建基础的Flask API框架和路由结构
4. 编写核心功能的测试用例（TDD先行）

前端原型部分：
5. 创建Vue.js + Element UI的基础项目结构
6. 设计主要页面的线框图和组件结构
7. 实现静态的配置管理、任务监控、日志查看页面
8. 建立前后端的API接口约定

目标：第一天结束时用户就能看到完整的界面原型
```

**TDD循环节点**：
- ✅ 红：基础功能测试全部失败（预期）
- ✅ 绿：实现最小可行的基础架构让测试通过
- ✅ 重构：优化项目结构和配置
- ✅ 原型：用户可以看到完整的界面原型和交互流程

### 第二天：TDD知识星球API + 配置界面
**AI提示词模板（前后端并行TDD）**：
```
前后端并行开发知识星球API模块：

后端TDD循环：
第一轮 - Token认证：
1. 红：编写Token认证API的测试用例
2. 绿：实现Token验证接口
3. 重构：优化认证代码结构

第二轮 - 内容获取API：
1. 红：编写获取内容的API测试
2. 绿：实现基础的API调用功能
3. 重构：抽象API客户端类

前端开发：
1. 实现配置管理页面的动态功能
2. 连接Token认证API，实现实时验证
3. 添加知识星球连接测试功能
4. 实现配置保存和加载

目标：用户可以在界面上配置知识星球连接并看到验证结果
```

**TDD循环节点**：
- ✅ 红：API调用测试失败
- ✅ 绿：基础API功能实现
- ✅ 重构：代码结构优化
- 🔄 重复：每个功能点都经历完整TDD循环

### 第三天：TDD WordPress集成 + 同步任务界面
**AI提示词模板（TDD循环）**：
```
使用TDD方法开发WordPress集成模块：

第一轮TDD循环 - WordPress连接：
1. 红：编写WordPress连接测试（Mock WordPress API）
2. 绿：实现基础连接功能
3. 重构：抽象WordPress客户端

第二轮TDD循环 - 文章发布：
1. 红：编写文章发布测试用例（包括失败场景）
2. 绿：实现文章发布功能
3. 重构：优化发布逻辑和错误处理

第三轮TDD循环 - 图片处理：
1. 红：编写图片上传到七牛云的测试
2. 绿：实现图片上传功能
3. 重构：优化图片处理流程

第四轮TDD循环 - 重复检测：
1. 红：编写内容重复检测测试
2. 绿：实现基于哈希的重复检测
3. 重构：优化检测算法
```

**TDD循环节点**：
- 每个功能都先写测试再实现
- 测试覆盖正常和异常场景
- 持续重构保持代码质量

### 第四天：TDD Redis缓存 + 实时通信
**AI提示词模板（TDD循环）**：
```
使用TDD方法开发Redis缓存系统：

第一轮TDD循环 - Redis连接：
1. 红：编写Redis连接和配置测试
2. 绿：实现Redis连接管理器
3. 重构：优化连接池和错误处理

第二轮TDD循环 - 缓存策略：
1. 红：编写各种缓存操作的测试（get/set/delete/expire）
2. 绿：实现缓存管理器
3. 重构：抽象缓存接口，支持不同数据类型

第三轮TDD循环 - 发布/订阅：
1. 红：编写消息发布和订阅的测试
2. 绿：实现基础的pub/sub功能
3. 重构：优化消息处理和错误恢复

第四轮TDD循环 - 降级机制：
1. 红：编写Redis故障时的降级测试
2. 绿：实现SQLite降级逻辑
3. 重构：优化故障检测和自动切换
```

**TDD循环节点**：
- 测试驱动缓存策略设计
- Mock Redis服务测试各种场景
- 集成测试验证缓存效果

### 第五天：TDD同步引擎 + 监控界面
**AI提示词模板（TDD循环）**：
```
使用TDD方法开发同步引擎：

第一轮TDD循环 - 增量同步算法：
1. 红：编写增量同步逻辑测试（时间戳、哈希对比）
2. 绿：实现基础的增量检测算法
3. 重构：优化算法性能和准确性

第二轮TDD循环 - 同步状态管理：
1. 红：编写同步状态跟踪测试
2. 绿：实现状态管理器
3. 重构：优化状态持久化和恢复

第三轮TDD循环 - 任务调度：
1. 红：编写定时任务调度测试
2. 绿：集成APScheduler实现调度
3. 重构：优化任务管理和错误处理

第四轮TDD循环 - 端到端同步：
1. 红：编写完整同步流程的集成测试
2. 绿：串联所有模块实现完整同步
3. 重构：优化性能和错误恢复
```

**TDD循环节点**：
- 核心算法测试驱动开发
- 集成测试验证整体流程
- 性能测试确保效率

### 第六天：端到端集成测试
**AI提示词模板（端到端集成）**：
```
完整的端到端集成测试和优化：

第一轮 - 完整同步流程测试：
1. 红：编写从知识星球到WordPress的完整同步测试
2. 绿：修复集成过程中发现的问题
3. 重构：优化整体性能和用户体验

第二轮 - 用户场景测试：
1. 红：编写典型用户使用场景的测试
2. 绿：完善用户体验和错误处理
3. 重构：优化界面交互和反馈

第三轮 - 压力和边界测试：
1. 红：编写大量数据和异常情况的测试
2. 绿：增强系统稳定性和容错能力
3. 重构：最终性能优化

目标：系统完全可用，用户体验流畅
```

**TDD循环节点**：
- API测试驱动后端开发
- 组件测试驱动前端开发
- E2E测试验证用户流程

### 第七天：TDD部署和集成测试
**AI提示词模板（TDD循环）**：
```
使用TDD方法完善部署和集成：

第一轮TDD循环 - Docker部署：
1. 红：编写Docker容器启动和健康检查测试
2. 绿：创建Docker和Docker Compose配置
3. 重构：优化容器配置和资源使用

第二轮TDD循环 - 生产环境测试：
1. 红：编写生产环境部署的集成测试
2. 绿：完善配置管理和环境变量处理
3. 重构：优化部署流程和监控

第三轮TDD循环 - 文档测试：
1. 红：编写文档示例代码的可执行测试
2. 绿：完善README和部署指南
3. 重构：确保文档与代码同步

最终TDD验证：
1. 红：编写完整的用户验收测试
2. 绿：修复所有发现的问题
3. 重构：最终代码质量优化
```

**TDD循环节点**：
- 部署脚本测试驱动开发
- 文档示例代码可执行验证
- 用户验收测试确保质量

## AI开发关键提示词库

### 代码生成提示词
```
请基于以下需求生成Python代码：
- 遵循PEP 8代码规范
- 包含完整的类型注解
- 添加详细的docstring文档
- 实现完整的错误处理
- 包含单元测试用例
- 考虑性能优化和安全性
```

### 调试优化提示词
```
请帮我分析和优化这段代码：
- 识别潜在的性能瓶颈
- 检查错误处理是否完善
- 建议代码结构改进
- 确保线程安全和并发处理
- 验证内存使用效率
```

### 测试生成提示词
```
为以下功能生成完整的测试用例：
- 单元测试覆盖所有方法
- 集成测试验证模块交互
- 异常情况和边界条件测试
- 性能测试和压力测试
- Mock外部依赖和API调用
```

## TDD质量保证体系

### TDD质量保证体系

### 每日TDD检查清单
- [ ] **红阶段**: 所有新功能都先写了失败的测试
- [ ] **绿阶段**: 实现了让测试通过的最小代码
- [ ] **重构阶段**: 优化了代码质量但保持测试通过
- [ ] **测试覆盖率**: 单元测试覆盖率 > 70%
- [ ] **集成测试**: 模块间交互测试通过
- [ ] **代码质量**: 通过pylint和black格式检查

### TDD里程碑验证
- **第1天**: 基础架构测试框架搭建完成
- **第2天**: 知识星球API模块TDD循环完成
- **第3天**: WordPress集成模块TDD循环完成
- **第4天**: Redis缓存系统TDD循环完成
- **第5天**: 同步引擎核心TDD循环完成
- **第6天**: Web界面TDD循环完成
- **第7天**: 部署和用户验收测试完成

### TDD测试金字塔
```
        /\
       /E2E\     <- 少量端到端测试
      /______\
     /        \
    /Integration\ <- 适量集成测试
   /__________\
  /            \
 /  Unit Tests  \ <- 大量单元测试
/________________\
```

### 测试类型和比例
- **单元测试**: 60% - 每个函数/方法的独立测试
- **集成测试**: 25% - 模块间交互测试
- **端到端测试**: 15% - 完整用户流程测试

## 风险控制

### AI开发风险
- **代码质量**: 每个模块完成后进行人工代码审查
- **安全性**: 使用AI生成安全检查清单并逐项验证
- **性能**: 关键路径进行性能测试和优化
- **兼容性**: 多环境测试确保跨平台兼容

### 应急预案
- 如果AI生成的代码有问题，准备手动修复的时间缓冲
- 关键功能准备备选实现方案
- 保持需求的灵活性，根据开发进度调整优先级

## 风险评估

### 技术风险
- 知识星球API可能发生变化
- WordPress XML-RPC接口限制
- Redis服务稳定性和内存管理
- 七牛云服务稳定性依赖

### 业务风险
- 用户需求变化
- 竞品出现
- 法律合规问题
- Redis部署复杂度增加用户使用门槛

### 缓解措施
- 设计灵活的API适配层
- 实现Redis故障时的SQLite降级机制
- 提供Docker Compose一键部署方案
- 提供多种图片存储选项
- 建立用户反馈机制
- 遵循开源最佳实践
- 提供详细的Redis配置和故障排除文档